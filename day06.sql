--JOIN
SELECT P.PLAYER_NAME, T.TEAM_NAME FROM PLAYER P, TEAM T;
SELECT P.PLAYER_NAME, T.TEAM_NAME FROM PLAYER P
	INNER JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID; -- INNER라는 키워드 생략 가능
	--WHERE T.TEAM_NAME = '아이파크';
	
-- ANSI 구문	
SELECT P.PLAYER_NAME, T.TEAM_NAME FROM PLAYER P
	JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID;
	
-- 오라클 구문
SELECT P.PLAYER_NAME, T.TEAM_NAME FROM PLAYER P, TEAM T
WHERE P.TEAM_ID = T.TEAM_ID;
------------------------------------------------------------------------------------

-- EMP, DEPT / 사원명, 부서명 , 지역
SELECT P.ENAME "사원명", T.DNAME "부서명",T.LOC "지역" FROM EMP P JOIN DEPT T ON P.DEPTNO = T.DEPTNO;

--PLAYER, TEAM / 송종국 선수의 팀명과 팀 전화번호
SELECT T.TEAM_NAME "팀명", P.PLAYER_NAME "선수명",T.TEL "전화번호" FROM PLAYER P JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID WHERE P.PLAYER_NAME = '송종국';
--SELECT T.TEAM_NAME "팀명", P.PLAYER_NAME "선수명",T.TEL "전화번호" FROM PLAYER P JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID AND P.PLAYER_NAME = '송종국';
-- 이것도 가능  WHERE절 대신에 ON절에 적어줘도 되는경우에는 ON에다 적어준다.

--EMPLOYEES, JOBS / 이름, 이메일, 직종, 직업명
SELECT E.FIRST_NAME||'-'||E.LAST_NAME "이름", E.EMAIL "이메일",J.JOB_TITLE "직업명", J.JOB_ID "직종"
FROM EMPLOYEES E JOIN JOBS J ON E.JOB_ID = J.JOB_ID;

--T_STUDENT, T_DEPARTMENT / 학생이름, 1전공 학과번호, 1전공 학과이름
SELECT T.NAME "학생이름", T.DEPTNO1 "1전공 학과번호", D.DNAME "1전공 학과이름"
FROM T_STUDENT T JOIN T_DEPARTMENT D ON T.DEPTNO1 = D.DEPTNO;

--T_STUDENT, T_PROFESSOR / 학생이름, 지도교수 번호, 지도교수 명 문제점 확인
SELECT T.NAME "학생이름", P.PROFNO "지도교수 번호", P.NAME "지도 교수 명"
FROM T_STUDENT T JOIN T_PROFESSOR P ON T.PROFNO = P.PROFNO;
-- NULL 이거나 조건에 부합하지 않는건 아예 빠져 버린다.

--T_STUDENT, T_DEPARTMENT, T_PROFESSOR / 학생의 이름, 학과이름, 지도교수 이름
SELECT T.NAME "학생이름", D.DNAME "학과이름", P.NAME "지도 교수 명"
FROM T_STUDENT T JOIN T_PROFESSOR P ON T.DEPTNO1 = P.DEPTNO JOIN T_DEPARTMENT D  ON T.DEPTNO1 = D.DEPTNO;

--비등가 조인

SELECT * FROM EMP;
SELECT * FROM SALGRADE;
SELECT
	E.ENAME 사원명, E.SAL 급여, S.GRADE 등급
FROM EMP E JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT 
*
FROM PLAYER P INNER JOIN TEAM T ON P.TEAM_ID = T.TEAM_ID;

-- 중복 되지 않게 하면,
SELECT 
*
FROM PLAYER P JOIN TEAM T USING(TEAM_ID);
-- NATURAL 을 사용하게 되면 알아서 겹치는걸 JOIN 해준다. USING을 없애도 가능 알아서 해주니까!
SELECT * FROM PLAYER
	NATURAL JOIN TEAM;
	
--OUTER JOIN
--RIGHT OUTER JOIN
-- LEFT 인지 RIGHT 인지는 JOIN을 기준으로 오른쪽걸 원하는지 왼쪽걸 원하는지 정하는 거다.
SELECT 
NVL(T.TEAM_NAME,'홈팀 없음') 팀명, S.STADIUM_NAME 구장명
FROM TEAM T RIGHT OUTER JOIN STADIUM S ON T.TEAM_ID = S.HOMETEAM_ID;
--LEFT OUTER JOIN
SELECT 
NVL(T.TEAM_NAME,'홈팀 없음') 팀명, S.STADIUM_NAME 구장명
FROM STADIUM S LEFT OUTER JOIN TEAM T ON T.TEAM_ID = S.HOMETEAM_ID;

-- 오라클 구문 이게 RIGHT OUTER JOIN 이다. (+)가 왼쪽이면 RIGHT , 오른쪽이면 LEFT 반대다.
SELECT 
NVL(T.TEAM_NAME,'홈팀 없음') 팀명, S.STADIUM_NAME 구장명
FROM TEAM T, STADIUM S WHERE T.TEAM_ID(+) = S.HOMETEAM_ID;

--CROSS JOIN
--거의 쓰지 않음, 이론상으로 존재
SELECT P.PLAYER_NAME, T.TEAM_NAME FROM PLAYER P CROSS JOIN TEAM T;
-- 이거 두개 같은거
SELECT P.PLAYER_NAME, T.TEAM_NAME FROM PLAYER P, TEAM T;


--OUTER JOIN 
SELECT T.NAME "학생이름", NVL(TO_CHAR(P.PROFNO),'배정안됨') "지도교수 번호", NVL(P.NAME,'배정안됨') "지도 교수 명"
FROM T_STUDENT T LEFT OUTER JOIN T_PROFESSOR P ON T.PROFNO = P.PROFNO;

-- 직원명, 매니져 명
SELECT FROM EMP;
SELECT E1.ENAME "직원명", E2.ENAME "매니저명"  FROM EMP E1 JOIN EMP E2 ON E1.MGR = E2.EMPNO;

SELECT * FROM T_STUDENT;
SELECT * FROM T_PROFESSOR;
--T_EMP2 T_POST / 사원의 이름과 직급, 현재 연봉, 해당 직급의 하한금액, 상한금액
SELECT 
E.NAME "사원이름", E.POST "사원 직급", E.PAY "현재 연봉", P.S_PAY "하한 금액", P.E_PAY "상한 금액"
FROM T_EMP2 E JOIN T_POST P ON E.POST = P.POST;
--T_CUSTOMER, T_GIFT / 받을 수 있는 상품을 조회하여 고객이름, 포인트 , 상품명
SELECT
C.C_NAME "고객 이름", C.C_POINT "고객 포인트", G.G_NAME "상품명"
FROM T_CUSTOMER C JOIN T_GIFT G ON C.C_POINT BETWEEN G.G_START AND G.G_END;
--위의 예제에서 조회한 상품의 이름과 필요수량 검색
SELECT
G_NAME "상품명", COUNT(*)
FROM T_CUSTOMER C JOIN T_GIFT G ON C.C_POINT BETWEEN G.G_START AND G.G_END GROUP BY G_NAME;

--T_STUDENT, T_EXAM, T_CREDIT / 학생들의 이름, 점수 학점
SELECT
S.NAME "학생이름", E.TOTAL "점수", C.GRADE "학점"
FROM T_STUDENT S JOIN T_EXAM01 E ON S.STUDNO = E.STUDNO JOIN T_CREDIT C ON E.TOTAL BETWEEN C.MIN_POINT AND C.MAX_POINT;
--T_DEPT2 / 부서명과 그 상위 부서명 검색
SELECT
D1.DNAME "부서명", D2.AREA "본사"
FROM T_DEPT2 D1 JOIN T_DEPT2 D2 ON D1.DCODE = D2.PDEPT;
--T_PROFESSOR / 교수번호, 교수이름, 입사일, 자신보다 입사일이 빠른 사람의 인원수 / 인원수 오름차순으로 정렬
-- 내가 뽑으려는 컬럼들이 GROUP BY가 되어있지 않으면 뽑을 수 없다! 따라서 안뽑히는걸 전부다 GROUP BY에 넣어 버리는거다.
SELECT
	P1.PROFNO 교수번호,
	P1.NAME 교수이름,
	P1.HIREDATE 입사일,
	COUNT(P2.HIREDATE) 인원수
FROM T_PROFESSOR P1 LEFT OUTER JOIN T_PROFESSOR P2 ON P1.HIREDATE > P2.HIREDATE GROUP BY P1.PROFNO,P1.NAME,P1.HIREDATE ORDER BY 4;

